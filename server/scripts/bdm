#!/bin/bash
# Bismark Devices Management script
#
# author: walter.dedonato@unina.it

# Load configuration file
. ~/etc/bdm.conf

# Aliases
query(){ sqlite3 -list $1 "$2"; }

# Help screen
# $1 = command
function help() 
{
	grep -A1 "^ *$1" <<-end
	Syntax:

	    $(basename $0) [options] <command>
	
	Commands:
	
	    config   <dev_id> [[opt=value] ...]  Show or Change <dev_id> configuration options (ALL applies)

	    console  <dev_id>                    Open a console on <dev_id> over the SSH tunnel
	
	    copy     <file> <dev_id>             Copy file to <dev_id> /tmp directory

	    exec     <dev_id> <command>          Execute a shell command on <dev_id>
	
	    list                                 List available devices and tunnels
	
	    readmsg                              Read incoming messages

	    tunnel   <dev_id> <on|off>           Open/Close a tunnel to <dev_id> using SSH port forwarding
	
	    upgrade  <dev_id> [rebuild]          Upgrade software on <dev_id> (ALL applies)


	    For internal use only:

	    settunnel <dev_id> <port>       Set the tunnel entry for <dev_id>

	    setuser   <dev_id> <username>   Set the SSH username for <dev_id>
	
	    clearmsg  [id]                  Delete pending messages

	Options:
	
	    -o <ssh_opts>    Additional SSH options
	    -p <fwd_port>    SSH tunnel port number (default: random)"
	    -t <timeout>     Max seconds to wait for messages (default: $MSG_TIMEOUT)
	end
	exit
}

# Parse command line
function parse()
{
	p=$*

	# Parse options
	while getopts 'o:p:t:' flag; do
		case $flag in
		o)
			SSH_OPTIONS+=" -$OPTARG"
		;;
		p)
			FWD_PORT=$OPTARG
		;;
		t)
			MSG_TIMEOUT=$OPTARG
		;;
		*)
			echo "Unknown option: $flag $OPTARG"
			help
		;;
		esac
	done
	shift $(( OPTIND - 1 ))	
	
	# Parse commands
	case $1 in
	tunnel)
		[ $2 ] || { echo -e "Missing parameter: <dev_id>\n"; help tunnel; }
		[ $3 ] || { echo -e "Missing parameter: on|off\n"; help tunnel; }
		[ $2 == ALL ] && { echo -e "ALL not allowed\n"; help tunnel; }
		[ $3 == "on" ] && start_tunnel $2
		[ $3 == "off" ] && stop_tunnel $2 $4
	;;
	console)
		[ $2 ] || { echo -e "Missing parameter: <dev_id>\n"; help console; }
		[ $2 == ALL ] && { echo -e "ALL not allowed\n"; help console; }
		echo "Connecting to $2"
		console $2
	;;
	exec)
		[ $2 ] || { echo -e "Missing parameter: <dev_id>\n"; help exec; }
		[ $3 ] || { echo -e "Missing parameter: <command>\n"; help exec; }
		[ $2 == ALL ] && { echo -e "ALL not allowed\n"; help exec; }
		echo "Executing \"${p#* * }\" on $2"
		console $2 ${p#* * }
	;;
	list)	
		list
	;;
	readmsg)
		read_msg
	;;
	upgrade)
		[ $2 ] || { echo -e "Missing parameter: <dev_id>\n"; help upgrade; }
		upgrade $2 $3 
	;;
	config)
		[ $2 ] || { echo -e "Missing parameter: <dev_id>\n"; help config; }
		[ $2 == ALL ] && echo $* | grep -q DEVICE_ID && { echo -e "ALL not allowed for DEVICE_ID\n"; help console; }
		$* 
	;;
	setuser)
		[ $2 ] || { echo -e "Missing parameter: <dev_id>\n"; help setuser; }
		[ $3 ] || { echo -e "Missing parameter: <username>\n"; help setuser; }
		setuser $2 $3
	;;
	settunnel)
		[ $2 ] || { echo -e "Missing parameter: <dev_id>\n"; help settunnel; }
		[ $3 ] || { echo -e "Missing parameter: <port>\n"; help settunnel; }
		settunnel $2 $3
	;;
	copy)
		[ $2 ] || { echo -e "Missing parameter: <file>\n"; help copy; }
		[ $3 ] || { echo -e "Missing parameter: <dev_id>\n"; help copy; }
		copy $2 $3
	;;
	clearmsg)
		clearmsg $2 
	;;
	*)
		[ $1 ] && echo "Unknown command: $1"
		help
	;;
	esac
}

## Utility functions ##

# Send message 
# $1 = dev id
# $2 = command
# $3 = value
function send_msg()
{
	# Add message to queue
	if [ $1 == ALL ]; then
		# Broadcast
		for dev in $(query $BDM_DB "SELECT id FROM devices;"); do
			query $MSG_DB "INSERT INTO messages('from', 'to', msg) VALUES('BDM','$dev','$2 $3');"
		done
	else
		# Unicast
		query $MSG_DB "INSERT INTO messages('from', 'to', msg) VALUES('BDM','$1','$2 $3');"

		# Wait for message delivery
		time=0
		while [ true ]; do
			rowid=$(query $MSG_DB "SELECT rowid FROM messages WHERE \"to\"='$1' AND msg='$2 $3';")
			[ ${#rowid} -eq 0 ] && return 0
			[ $((time++)) -eq $MSG_TIMEOUT ] && return 1
			echo -n "."
			sleep 1
		done
	fi
}

# Receive message 
# $1 = dev id
function recv_msg()
{
	# Wait for message 
	time=0
	while [ true ]; do
		info=$(query $MSG_DB "SELECT rowid,msg FROM messages WHERE \"from\"='$1';")
		if [ ${#info} -gt 0 ]; then
			echo
			read_msg $1
			return 0
		fi
		[ $((time++)) -eq $MSG_TIMEOUT ] && return 1
		echo -n "."
		sleep 1
	done
}

# Check forwarding port
# $1 = port number
function check_fwd_port()
{
	if [ $(netstat -lnt | grep -c "127.0.0.1:$FWD_PORT\>") -gt 0 ]; then
		return 0
	else
		return 1
	fi
}

# Generate a valid SSH forwarding port
function gen_fwd_port()
{
	# Test requested port number availability
	if [ $FWD_PORT ]; then
		if (check_fwd_port $FWD_PORT); then
			echo "warning: $FWD_PORT not available"
		else
			return 0
		fi
	fi

	# Find a random available port number
	RANDOM=$(( `date +%s` % 32767 ))
	FWD_PORT=$(( RANDOM + 10000 ))
	while (check_fwd_port $FWD_PORT); do
		FWD_PORT=$(( RANDOM + 10000 ))
	done
}

# Get dev currently used forwarding port
# $1 = dev id
function get_fwd_port()
{
	# Query tunnels db
	FWD_PORT=$(query $BDM_DB "SELECT port FROM tunnels WHERE id='$1' LIMIT 1;")
	[ $FWD_PORT ] || return 1
}


# Check tunnel availability
# $1 = dev id
# $2 = port number
# rv = 0 if tunnel is active
# rv = 1 if tunnel is not in DB
# rv = 2 if tunnel is opening
# rv = 3 if tunnel is expired
function check_tunnel()
{
	if [ $2 ]; then
		FWD_PORT=$2
	else
		get_fwd_port $1 || return 1
	fi
	
	if check_fwd_port $FWD_PORT; then
		return 0
	else
		query $BDM_DB "DELETE FROM tunnels WHERE id='$1' AND port=$FWD_PORT AND ts<$(date +%s);"
		get_fwd_port $1 && return 2 || return 3
	fi
}

# Wait for tunnel availability
# $1 = port number
function wait_tunnel()
{
	echo -en "\nWaiting for tunnel establishment"
	time=0
	while [ true ]; do 
		port=$(netstat -lnt | grep -c "127.0.0.1:$1")

		if [ $port -ge 1 ]; then
			echo -e "\nTunnel ready on 127.0.0.1:$1"
			return 0
		elif [ $((time++)) -eq $SSH_PORT_FWD_WAIT ]; then 
			echo "Error: tunnel not found"
			return 1
		fi

		echo -n "." 
		sleep 1
	done
}

## User command functions ##

# Start new tunnel
# $1 = dev id
function start_tunnel()
{
	if check_tunnel $1; then 
		echo "Tunnel listening on 127.0.0.1:$FWD_PORT" 
		return 1
	fi
	gen_fwd_port

	echo "Starting SSH tunnel to dev $1 on port $FWD_PORT"
	send_msg $1 fwd $FWD_PORT || { echo -e "\nDelivery to $1 failed"; return 2; }
 	wait_tunnel $FWD_PORT || return 3
}

# Connect to the SSH server on the dev
# $1 = dev id
# $* = optional shell command
function console()
{
	if [ ! $FWD_PORT ]; then 
		start_tunnel $1
		case $? in
		0) new=1 ;;
		2) return 1;;
		esac
	fi

	[ $2 ] && { p=$* ; cmd=${p#* } ; }
	SSH_USER=$(query $BDM_DB "SELECT user FROM devices WHERE id='$1'")
	ssh $SSH_USER@127.0.0.1 -p $FWD_PORT $SSH_OPTIONS -i $SSH_KEY $cmd 2>/dev/null

	[ $new ] && stop_tunnel $1
}

# Stop active tunnel
# $1 = dev id
function stop_tunnel()
{
	if ! check_tunnel $1; then
		echo "Tunnel expired"
		return 1 
	fi

	echo "Stopping SSH tunnel to device $1 on port $FWD_PORT"
	pid=$(sudo netstat -lntp | grep 127.0.0.1:$FWD_PORT | awk '{ print $7 }')
	kill ${pid%/*}

	if (check_fwd_port $FWD_PORT); then
		echo "Unable to close tunnel"
	else
		echo "Tunnel closed"
		query $BDM_DB "DELETE FROM tunnels WHERE id='$1' AND port=$FWD_PORT;"
	fi
}

# Update device software
# $1 = dev id
# $2 = rebuild
function upgrade(){
	echo "Upgrading $1"

	# Update version number
	svn update ~/bismark
	svn info ~/bismark | awk '/^Rev/{ print $2 ; exit }' > ~/bismark/device/VERSION
	VERSION=$(cat ~/bismark/device/VERSION)

	# Create last release packages
	[ $2 ] && rm -f ~/bismark/device/dev-*.tgz
	for type in $DEV_TYPES; do
		if [ ! -e ~/bismark/device/dev-$type-$VERSION.tgz ]; then
			echo "Creating $type package version $VERSION:"

			# Clean & create package tree
			rm -f ~/bismark/device/dev-$type-*.tgz
			rm -rf /tmp/pkg/$type
			mkdir -p /tmp/pkg/$type
			mkdir /tmp/pkg/$type/{conf,scripts,bin,lib}

			# Copy files
			(
			 cd ~/bismark/device
			 cp VERSION /tmp/pkg/$type
			 cp -d conf/* /tmp/pkg/$type/conf
			 cp -d scripts/* /tmp/pkg/$type/scripts
			 [ -e bin/$type ] && cp -d bin/$type/* /tmp/pkg/$type/bin
			 [ -e lib/$type ] && cp -d lib/$type/* /tmp/pkg/$type/lib
			)

			# Create tgz archive
			(
			 cd /tmp/pkg/$type
			 tar -czvf ~/bismark/device/dev-$type-$VERSION.tgz *
			)
		fi
	done

	# Start upgrade script
	echo "Executing upgrade:"
	if check_tunnel $1; then
		console $1 "~/scripts/action" update
	else
		# Send message
		send_msg $1 update $VERSION || { [ $1 == ALL ] && echo done || { echo -e "\nDelivery to $1 pending"; return 1; } ; }

		# Wait reply
		echo -e "\nWaiting for upgrade log:"
		if [ $1 == ALL ]; then
			for ((i=$MSG_TIMEOUT;i>0;i--)); do
				echo -ne "Remaining $i seconds  \r"
				sleep 1
			done
			echo
			read_msg
		else
			recv_msg $1 || { echo -e "\nNo messages from $id"; return 2; } 
		fi
	fi
}

# Show/push configuration options
# $1 = dev id
# $* = options
function config()
{
	id=$1
	shift
	
	params=$(echo $* | tr ' ' '&')
	echo -n "Sending config request to $id"
	send_msg $id config $params || { echo -e "\nDevice $id not found"; return 1; }
	
	# Wait reply
	echo -e "\nWaiting for config log:"
	if [ $id == ALL ]; then
		for ((i=$MSG_TIMEOUT;i>0;i--)); do
			echo -ne "Remaining $i seconds  \r"
			sleep 1
		done
		echo
		read_msg
	else
		recv_msg $id || { echo -e "\nNo messages from $id"; return 2; }
	fi
}

# List active devices and tunnels
# $1 = update flag
function list()
{
	# Dump devices table
	echo -e "${BLUE}Latest version: ${WHITE}$VERSION"
	echo -e "${BLUE}\nDevices:"
	echo -e "${WHITE}ID\tIP\t\tUSER\tVERSION\tLAST PROBE"
	IFS=$'\n' 
	for dev in $(query $BDM_DB 'SELECT id,ip,user,version,ts FROM devices ORDER BY id;'); do
		IFS=$'|' read id ip user ver ts <<< "$dev"
		off_time=$(( $(date +%s) - $ts ))
		if [ $off_time -lt 300 ]; then
			echo -ne $GREEN
		elif [ $off_time -lt 900 ]; then
			echo -ne $YELLOW
		else
			echo -ne $RED
		fi
		printf "%s\t%s\t%s\t%s\t%s\n" $id $ip $user $ver $(date -d @$ts +"%Y-%m-%d %H:%M:%S")
	done

	# Dump tunnels table
	echo -e "${BLUE}\nTunnels:"
	echo -e "${WHITE}ID\tPORT\tSTART TIME"
	echo -ne $GREEN
	IFS=$'\n' 
	for dev in $(query $BDM_DB 'SELECT * FROM tunnels ORDER BY id;'); do
		IFS=$'|' read id port ts <<< "$dev"
		check_tunnel $id $port
		if [ $? -eq 0 ]; then
			echo -ne $GREEN
		elif [ $? -eq 2 ]; then
			echo -ne $YELLOW
		else
			echo -ne $RED
		fi
		printf "%s\t%s\t%s\n" $id $port $(date -d @$ts +"%Y-%m-%d %H:%M:%S")
	done
	echo -ne $NO_COLOR

	# Dump messages table
	echo -e "${BLUE}\nPending Messages:"
	echo -e "${WHITE}ID\tFROM\tTO\tMESSAGE"
	echo -ne $MAGENTA
	IFS=$'\n' 
	for message in $(query $MSG_DB 'SELECT rowid,* FROM messages ORDER BY "from","to";'); do
		IFS=$'|' read id from to msg <<< "$message"
		printf "%s\t%s\t%s\t%s\n" $id $from $to $msg
	done
	echo -ne $NO_COLOR
}

# Copy file to device /tmp directory
# $1 = file
# $2 = dev id
function copy()
{
	if [ ! $FWD_PORT ]; then 
		start_tunnel $2
		case $? in
		0) new=1 ;;
		2) return 1;;
		esac
	fi

	SSH_USER=$(query $BDM_DB "SELECT user FROM devices WHERE id='$2'")
	scp -P $FWD_PORT $SSH_OPTIONS -i $SSH_KEY $1 $SSH_USER@127.0.0.1:/tmp  
}

# Read messages
# $1 = id
function read_msg()
{
	if [ $1 ]; then
		rows=$(query $MSG_DB "SELECT rowid,* FROM messages WHERE \"from\"='$1';")
	else
		rows=$(query $MSG_DB "SELECT rowid,* FROM messages WHERE \"to\"='BDM';")
	fi

	if [ ${#rows} -gt 0 ]; then
		IFS=$'\n'
		for row in $rows; do
			IFS=$'|' read mid from to msg <<< "$row"
			echo "Message from $from: $msg"
			echo "------------------------"
			awk '
				BEGIN{ out = 0 }
				/^END - '$msg'/{ exit }
				(out == 1){ print }
				/'$msg'/{ out=1 }
			' ~/var/log/devices/$from.log
			echo "------------------------"

			query $MSG_DB "DELETE FROM messages WHERE rowid='$mid';"
		done
	else
		echo "No incoming messages"
	fi
}

## Internal commands ##

# Set device SSH username
# $1 = dev id
# $2 = username
function setuser()
{
	echo -n "Setting $1 SSH user to $2..."
	if [ $(query $BDM_DB "SELECT id FROM devices WHERE id='$1';") ]; then
		query $BDM_DB "UPDATE devices SET user='$2' WHERE id='$1';"
	else
		query $BDM_DB "INSERT INTO devices (id, user) VALUES('$1','$2');"
	fi
	echo done
}

# Set device tunnel entry
# $1 = dev id
# $2 = port
function settunnel()
{
	echo -n "Setting tunnel db entry for $1 on port $2..."
	query $BDM_DB "INSERT INTO tunnels (id, port, ts) VALUES('$1',$2,$(date +%s));"
	echo done
}

# Clear pending messages
# $1 = id
function clearmsg()
{
	if [ $1 ]; then
		query $MSG_DB "DELETE FROM messages WHERE rowid=$1;"
	else
		echo "Delete all pending messages (y/N)?"
		read a
		[ $a == "y" ] && query $MSG_DB "DELETE FROM messages;"
	fi
}

## Main ##
# Parse command-line
parse $*

